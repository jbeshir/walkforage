// Integration Phase - Generate icon loader and update resource data
import * as fs from 'fs';
import * as path from 'path';
import { ASSETS_DIR, SRC_DIR } from './lib/config';
import { ResourceType } from './lib/types';

// Import resource data
import { STONES } from '../../src/data/stones';
import { WOODS } from '../../src/data/woods';
import { FOODS } from '../../src/data/foods';

const ICONS_UTIL_PATH = path.join(SRC_DIR, 'utils', 'icons.ts');

interface IconInfo {
  type: ResourceType;
  id: string;
  relativePath: string;
}

function scanIcons(): IconInfo[] {
  const icons: IconInfo[] = [];

  const types: ResourceType[] = ['stone', 'wood', 'food'];
  for (const type of types) {
    const dir = path.join(ASSETS_DIR, `${type}s`);
    if (!fs.existsSync(dir)) {
      console.log(`  No icons directory for ${type}s`);
      continue;
    }

    const files = fs.readdirSync(dir);
    for (const file of files) {
      if (file.endsWith('.png')) {
        const id = file.replace('.png', '');
        icons.push({
          type,
          id,
          relativePath: `icons/${type}s/${file}`,
        });
      }
    }
  }

  return icons;
}

function generateIconLoader(icons: IconInfo[]): string {
  const stoneIcons = icons.filter((i) => i.type === 'stone');
  const woodIcons = icons.filter((i) => i.type === 'wood');
  const foodIcons = icons.filter((i) => i.type === 'food');

  // Generate require statements for each type
  const generateRequireMap = (items: IconInfo[], typePlural: string): string => {
    if (items.length === 0) {
      return `// No ${typePlural} icons generated yet`;
    }
    const entries = items
      .map((i) => `  ${i.id}: require('../../assets/${i.relativePath}'),`)
      .join('\n');
    return entries;
  };

  return `// Auto-generated icon loader - DO NOT EDIT MANUALLY
// Generated by: npm run icons:integrate
// Regenerate after adding new icons

import { ImageSourcePropType } from 'react-native';
import { MaterialType } from '../config/materials';

// Stone icons
const STONE_ICONS: Record<string, ImageSourcePropType> = {
${generateRequireMap(stoneIcons, 'stone')}
};

// Wood icons
const WOOD_ICONS: Record<string, ImageSourcePropType> = {
${generateRequireMap(woodIcons, 'wood')}
};

// Food icons
const FOOD_ICONS: Record<string, ImageSourcePropType> = {
${generateRequireMap(foodIcons, 'food')}
};

// Map material types to icon maps
const ICON_MAPS: Partial<Record<MaterialType, Record<string, ImageSourcePropType>>> = {
  stone: STONE_ICONS,
  wood: WOOD_ICONS,
  food: FOOD_ICONS,
};

/**
 * Get the icon for a resource.
 * Returns the require() result for use with Image source prop, or null if no icon exists.
 */
export function getResourceIcon(
  type: MaterialType,
  resourceId: string
): ImageSourcePropType | null {
  const iconMap = ICON_MAPS[type];
  if (!iconMap) {
    return null;
  }
  return iconMap[resourceId] ?? null;
}

/**
 * Check if a resource has an icon.
 */
export function hasResourceIcon(type: MaterialType, resourceId: string): boolean {
  return getResourceIcon(type, resourceId) !== null;
}

/**
 * Get counts of available icons.
 */
export function getIconCounts(): { stones: number; woods: number; foods: number; total: number } {
  const stones = Object.keys(STONE_ICONS).length;
  const woods = Object.keys(WOOD_ICONS).length;
  const foods = Object.keys(FOOD_ICONS).length;
  return {
    stones,
    woods,
    foods,
    total: stones + woods + foods,
  };
}
`;
}

export function runIntegrate(): void {
  console.log('Starting integration phase...');

  // Scan for generated icons
  console.log('\nScanning for icons...');
  const icons = scanIcons();

  console.log(`  Found ${icons.length} icons:`);
  console.log(`    Stones: ${icons.filter((i) => i.type === 'stone').length}`);
  console.log(`    Woods: ${icons.filter((i) => i.type === 'wood').length}`);
  console.log(`    Foods: ${icons.filter((i) => i.type === 'food').length}`);

  // Generate icon loader
  console.log('\nGenerating icon loader...');
  const loaderContent = generateIconLoader(icons);

  // Ensure utils directory exists
  const utilsDir = path.dirname(ICONS_UTIL_PATH);
  if (!fs.existsSync(utilsDir)) {
    fs.mkdirSync(utilsDir, { recursive: true });
  }

  fs.writeFileSync(ICONS_UTIL_PATH, loaderContent);
  console.log(`  Written to: ${ICONS_UTIL_PATH}`);

  // Report coverage
  console.log('\nIcon coverage:');
  const stoneIds = STONES.map((s) => s.id);
  const woodIds = WOODS.map((w) => w.id);
  const foodIds = FOODS.map((f) => f.id);

  const stoneIcons = icons.filter((i) => i.type === 'stone').map((i) => i.id);
  const woodIcons = icons.filter((i) => i.type === 'wood').map((i) => i.id);
  const foodIcons = icons.filter((i) => i.type === 'food').map((i) => i.id);

  const stoneCoverage = stoneIds.filter((id) => stoneIcons.includes(id)).length;
  const woodCoverage = woodIds.filter((id) => woodIcons.includes(id)).length;
  const foodCoverage = foodIds.filter((id) => foodIcons.includes(id)).length;

  console.log(`  Stones: ${stoneCoverage}/${stoneIds.length}`);
  console.log(`  Woods: ${woodCoverage}/${woodIds.length}`);
  console.log(`  Foods: ${foodCoverage}/${foodIds.length}`);

  // List missing icons
  const missingStones = stoneIds.filter((id) => !stoneIcons.includes(id));
  const missingWoods = woodIds.filter((id) => !woodIcons.includes(id));
  const missingFoods = foodIds.filter((id) => !foodIcons.includes(id));

  if (missingStones.length + missingWoods.length + missingFoods.length > 0) {
    console.log('\nMissing icons:');
    if (missingStones.length > 0) {
      console.log(
        `  Stones (${missingStones.length}): ${missingStones.slice(0, 5).join(', ')}${missingStones.length > 5 ? '...' : ''}`
      );
    }
    if (missingWoods.length > 0) {
      console.log(
        `  Woods (${missingWoods.length}): ${missingWoods.slice(0, 5).join(', ')}${missingWoods.length > 5 ? '...' : ''}`
      );
    }
    if (missingFoods.length > 0) {
      console.log(
        `  Foods (${missingFoods.length}): ${missingFoods.slice(0, 5).join(', ')}${missingFoods.length > 5 ? '...' : ''}`
      );
    }
  }

  console.log('\nIntegration complete!');
}

// Run if called directly
if (require.main === module) {
  runIntegrate();
}
